// <auto-generated />
#nullable enable

using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;

namespace DotNix.Parsing;

internal static partial class TreeSitter
{
    private static Parser<object?> TODO => throw new NotImplementedException();
    
    private static Parser<string> regex([StringSyntax("regex")] string pattern)
{
    var regex_ = new Regex(pattern);
    return input =>
    {
        var match = regex_.Match(input.Value, input.Index);
        if (!match.Success || match.Index != input.Index)
            return ParserResult.EmptyError<string>(ParserError.Message(input.Pos, $"Did not match pattern"));

          return str(match.Value)(input);
    };
}
    
    public abstract partial class Rules
    {
        public virtual Parser<object?> source_code => field ??=
            choice((Parser<object?>[])[
                attempt((lazyp(() => _expression)).label("expression")),
                attempt(eof.Map(x => (object?)x)),
            ]);
        
        public virtual Parser<object?> _expression => field ??=
            lazyp(() => _expr_function_expression);
        
        public virtual Parser<object?> keyword => field ??=
            regex("if|then|else|let|inherit|in|rec|with|assert").Map(x => (object?)x);
        
        public virtual Parser<object?> identifier => field ??=
            regex("[a-zA-Z_][a-zA-Z0-9_\\'\\-]*").Map(x => (object?)x);
        
        public virtual Parser<object?> variable_expression => field ??=
            (lazyp(() => identifier)).label("name");
        
        public virtual Parser<object?> integer_expression => field ??=
            regex("[0-9]+").Map(x => (object?)x);
        
        public virtual Parser<object?> float_expression => field ??=
            regex("(([1-9][0-9]*\\.[0-9]*)|(0?\\.[0-9]+))([Ee][+-]?[0-9]+)?").Map(x => (object?)x);
        
        public virtual Parser<object?> path_expression => field ??=
            chain((Parser<object?>[])[
                (lazyp(() => _path_start)).label("path_fragment"),
                many(LEXEME(choice((Parser<object?>[])[
                    attempt(lazyp(() => path_fragment)),
                    attempt((lazyp(() => _immediate_interpolation)).label("interpolation")),
                ]))).Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> _hpath_start => field ??=
            regex("\\~\\/[a-zA-Z0-9\\._\\-\\+\\/]+").Map(x => (object?)x);
        
        public virtual Parser<object?> hpath_expression => field ??=
            chain((Parser<object?>[])[
                (lazyp(() => _hpath_start)).label("path_fragment"),
                many(LEXEME(choice((Parser<object?>[])[
                    attempt(lazyp(() => path_fragment)),
                    attempt((lazyp(() => _immediate_interpolation)).label("interpolation")),
                ]))).Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> spath_expression => field ??=
            regex("<[a-zA-Z0-9\\._\\-\\+]+(\\/[a-zA-Z0-9\\._\\-\\+]+)*>").Map(x => (object?)x);
        
        public virtual Parser<object?> uri_expression => field ??=
            regex("[a-zA-Z][a-zA-Z0-9\\+\\-\\.]*:[a-zA-Z0-9%\\/\\?:@\\&=\\+\\$,\\-_\\.\\!\\~\\*\\']+").Map(x => (object?)x);
        
        public virtual Parser<object?> _expr_function_expression => field ??=
            choice((Parser<object?>[])[
                attempt(lazyp(() => function_expression)),
                attempt(lazyp(() => assert_expression)),
                attempt(lazyp(() => with_expression)),
                attempt(lazyp(() => let_expression)),
                attempt(lazyp(() => _expr_if)),
            ]);
        
        public virtual Parser<object?> function_expression => field ??=
            choice((Parser<object?>[])[
                attempt(chain((Parser<object?>[])[
                    (lazyp(() => identifier)).label("universal"),
                    str(":").Map(x => (object?)x),
                    (lazyp(() => _expr_function_expression)).label("body"),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    (lazyp(() => formals)).label("formals"),
                    str(":").Map(x => (object?)x),
                    (lazyp(() => _expr_function_expression)).label("body"),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    (lazyp(() => formals)).label("formals"),
                    str("@").Map(x => (object?)x),
                    (lazyp(() => identifier)).label("universal"),
                    str(":").Map(x => (object?)x),
                    (lazyp(() => _expr_function_expression)).label("body"),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    (lazyp(() => identifier)).label("universal"),
                    str("@").Map(x => (object?)x),
                    (lazyp(() => formals)).label("formals"),
                    str(":").Map(x => (object?)x),
                    (lazyp(() => _expr_function_expression)).label("body"),
                ]).Map(x => (object?)x)),
            ]);
        
        public virtual Parser<object?> formals => field ??=
            choice((Parser<object?>[])[
                attempt(chain((Parser<object?>[])[
                    str("{").Map(x => (object?)x),
                    str("}").Map(x => (object?)x),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    str("{").Map(x => (object?)x),
                    chain((Parser<object?>[])[
                        (lazyp(() => formal)).label("formal"),
                        many(LEXEME(chain((Parser<object?>[])[
                            str(",").Map(x => (object?)x),
                            (lazyp(() => formal)).label("formal"),
                        ]).Map(x => (object?)x))).Map(x => (object?)x),
                    ]).Map(x => (object?)x),
                    str("}").Map(x => (object?)x),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    str("{").Map(x => (object?)x),
                    chain((Parser<object?>[])[
                        (lazyp(() => formal)).label("formal"),
                        many(LEXEME(chain((Parser<object?>[])[
                            str(",").Map(x => (object?)x),
                            (lazyp(() => formal)).label("formal"),
                        ]).Map(x => (object?)x))).Map(x => (object?)x),
                    ]).Map(x => (object?)x),
                    choice((Parser<object?>[])[
                        attempt(chain((Parser<object?>[])[
                            str(",").Map(x => (object?)x),
                            choice((Parser<object?>[])[
                                attempt((lazyp(() => ellipses)).label("ellipses")),
                                attempt(eof.Map(x => (object?)x)),
                            ]),
                        ]).Map(x => (object?)x)),
                        attempt(eof.Map(x => (object?)x)),
                    ]),
                    str("}").Map(x => (object?)x),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    str("{").Map(x => (object?)x),
                    (lazyp(() => ellipses)).label("ellipses"),
                    str("}").Map(x => (object?)x),
                ]).Map(x => (object?)x)),
            ]);
        
        public virtual Parser<object?> formal => field ??=
            chain((Parser<object?>[])[
                (lazyp(() => identifier)).label("name"),
                choice((Parser<object?>[])[
                    attempt(chain((Parser<object?>[])[
                        str("?").Map(x => (object?)x),
                        (lazyp(() => _expression)).label("default"),
                    ]).Map(x => (object?)x)),
                    attempt(eof.Map(x => (object?)x)),
                ]),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> ellipses => field ??=
            str("...").Map(x => (object?)x);
        
        public virtual Parser<object?> assert_expression => field ??=
            chain((Parser<object?>[])[
                str("assert").Map(x => (object?)x),
                (lazyp(() => _expression)).label("condition"),
                str(";").Map(x => (object?)x),
                (lazyp(() => _expr_function_expression)).label("body"),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> with_expression => field ??=
            chain((Parser<object?>[])[
                str("with").Map(x => (object?)x),
                (lazyp(() => _expression)).label("environment"),
                str(";").Map(x => (object?)x),
                (lazyp(() => _expr_function_expression)).label("body"),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> let_expression => field ??=
            chain((Parser<object?>[])[
                str("let").Map(x => (object?)x),
                choice((Parser<object?>[])[
                    attempt(lazyp(() => binding_set)),
                    attempt(eof.Map(x => (object?)x)),
                ]),
                str("in").Map(x => (object?)x),
                (lazyp(() => _expr_function_expression)).label("body"),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> _expr_if => field ??=
            choice((Parser<object?>[])[
                attempt(lazyp(() => if_expression)),
                attempt(lazyp(() => _expr_op)),
            ]);
        
        public virtual Parser<object?> if_expression => field ??=
            chain((Parser<object?>[])[
                str("if").Map(x => (object?)x),
                (lazyp(() => _expression)).label("condition"),
                str("then").Map(x => (object?)x),
                (lazyp(() => _expression)).label("consequence"),
                str("else").Map(x => (object?)x),
                (lazyp(() => _expression)).label("alternative"),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> _expr_op => field ??=
            choice((Parser<object?>[])[
                attempt(lazyp(() => has_attr_expression)),
                attempt(lazyp(() => unary_expression)),
                attempt(lazyp(() => binary_expression)),
                attempt(lazyp(() => _expr_apply_expression)),
            ]);
        
        public virtual Parser<object?> has_attr_expression => field ??=
            /* PREC [11] */ chain((Parser<object?>[])[
                (lazyp(() => _expr_op)).label("expression"),
                (str("?").Map(x => (object?)x)).label("operator"),
                (lazyp(() => attrpath)).label("attrpath"),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> unary_expression => field ??=
            choice((Parser<object?>[])[
                attempt(/* PREC [ 7] */ chain((Parser<object?>[])[
                    (str("!").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("argument"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC [12] */ chain((Parser<object?>[])[
                    (str("-").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("argument"),
                ]).Map(x => (object?)x)),
            ]);
        
        public virtual Parser<object?> binary_expression => field ??=
            choice((Parser<object?>[])[
                attempt(/* PREC_LEFT [ 4] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("==").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 4] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("!=").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 5] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("<").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 5] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("<=").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 5] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str(">").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 5] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str(">=").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 3] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("&&").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 2] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("||").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 8] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("+").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 8] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("-").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 9] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("*").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_LEFT [ 9] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("/").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_RIGHT[ 1] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("->").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_RIGHT[ 6] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("//").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
                attempt(/* PREC_RIGHT[10] */ chain((Parser<object?>[])[
                    (lazyp(() => _expr_op)).label("left"),
                    (str("++").Map(x => (object?)x)).label("operator"),
                    (lazyp(() => _expr_op)).label("right"),
                ]).Map(x => (object?)x)),
            ]);
        
        public virtual Parser<object?> _expr_apply_expression => field ??=
            choice((Parser<object?>[])[
                attempt(lazyp(() => apply_expression)),
                attempt(lazyp(() => _expr_select_expression)),
            ]);
        
        public virtual Parser<object?> apply_expression => field ??=
            chain((Parser<object?>[])[
                (lazyp(() => _expr_apply_expression)).label("function"),
                (lazyp(() => _expr_select_expression)).label("argument"),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> _expr_select_expression => field ??=
            choice((Parser<object?>[])[
                attempt(lazyp(() => select_expression)),
                attempt(lazyp(() => _expr_simple)),
            ]);
        
        public virtual Parser<object?> select_expression => field ??=
            choice((Parser<object?>[])[
                attempt(chain((Parser<object?>[])[
                    (lazyp(() => _expr_simple)).label("expression"),
                    str(".").Map(x => (object?)x),
                    (lazyp(() => attrpath)).label("attrpath"),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    (lazyp(() => _expr_simple)).label("expression"),
                    str(".").Map(x => (object?)x),
                    (lazyp(() => attrpath)).label("attrpath"),
                    str("or").Map(x => (object?)x),
                    (lazyp(() => _expr_select_expression)).label("default"),
                ]).Map(x => (object?)x)),
            ]);
        
        public virtual Parser<object?> _expr_simple => field ??=
            choice((Parser<object?>[])[
                attempt(lazyp(() => variable_expression)),
                attempt(lazyp(() => integer_expression)),
                attempt(lazyp(() => float_expression)),
                attempt(lazyp(() => string_expression)),
                attempt(lazyp(() => indented_string_expression)),
                attempt(lazyp(() => path_expression)),
                attempt(lazyp(() => hpath_expression)),
                attempt(lazyp(() => spath_expression)),
                attempt(lazyp(() => uri_expression)),
                attempt(lazyp(() => parenthesized_expression)),
                attempt(lazyp(() => attrset_expression)),
                attempt(lazyp(() => let_attrset_expression)),
                attempt(lazyp(() => rec_attrset_expression)),
                attempt(lazyp(() => list_expression)),
            ]);
        
        public virtual Parser<object?> parenthesized_expression => field ??=
            chain((Parser<object?>[])[
                str("(").Map(x => (object?)x),
                (lazyp(() => _expression)).label("expression"),
                str(")").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> attrset_expression => field ??=
            chain((Parser<object?>[])[
                str("{").Map(x => (object?)x),
                choice((Parser<object?>[])[
                    attempt(lazyp(() => binding_set)),
                    attempt(eof.Map(x => (object?)x)),
                ]),
                str("}").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> let_attrset_expression => field ??=
            chain((Parser<object?>[])[
                str("let").Map(x => (object?)x),
                str("{").Map(x => (object?)x),
                choice((Parser<object?>[])[
                    attempt(lazyp(() => binding_set)),
                    attempt(eof.Map(x => (object?)x)),
                ]),
                str("}").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> rec_attrset_expression => field ??=
            chain((Parser<object?>[])[
                str("rec").Map(x => (object?)x),
                str("{").Map(x => (object?)x),
                choice((Parser<object?>[])[
                    attempt(lazyp(() => binding_set)),
                    attempt(eof.Map(x => (object?)x)),
                ]),
                str("}").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> string_expression => field ??=
            chain((Parser<object?>[])[
                str("\"").Map(x => (object?)x),
                many(LEXEME(choice((Parser<object?>[])[
                    attempt(lazyp(() => string_fragment)),
                    attempt(lazyp(() => interpolation)),
                    attempt(choice((Parser<object?>[])[
                        attempt(lazyp(() => escape_sequence)),
                        attempt(chain((Parser<object?>[])[
                            lazyp(() => dollar_escape),
                            (str("$").Map(x => (object?)x)).label("string_fragment"),
                        ]).Map(x => (object?)x)),
                    ])),
                ]))).Map(x => (object?)x),
                str("\"").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> escape_sequence => field ??=
            regex("\\\\([^$]|\\s)").Map(x => (object?)x);
        
        public virtual Parser<object?> indented_string_expression => field ??=
            chain((Parser<object?>[])[
                str("''").Map(x => (object?)x),
                many(LEXEME(choice((Parser<object?>[])[
                    attempt((lazyp(() => _indented_string_fragment)).label("string_fragment")),
                    attempt(lazyp(() => interpolation)),
                    attempt(choice((Parser<object?>[])[
                        attempt((lazyp(() => _indented_escape_sequence)).label("escape_sequence")),
                        attempt(chain((Parser<object?>[])[
                            (lazyp(() => _indented_dollar_escape)).label("dollar_escape"),
                            (str("$").Map(x => (object?)x)).label("string_fragment"),
                        ]).Map(x => (object?)x)),
                    ])),
                ]))).Map(x => (object?)x),
                str("''").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> _indented_escape_sequence => field ??=
            regex("'''|''\\\\([^$]|\\s)").Map(x => (object?)x);
        
        public virtual Parser<object?> binding_set => field ??=
            many1(LEXEME((choice((Parser<object?>[])[
                attempt(lazyp(() => binding)),
                attempt(lazyp(() => inherit)),
                attempt(lazyp(() => inherit_from)),
            ])).label("binding"))).Map(x => (object?)x);
        
        public virtual Parser<object?> binding => field ??=
            chain((Parser<object?>[])[
                (lazyp(() => attrpath)).label("attrpath"),
                str("=").Map(x => (object?)x),
                (lazyp(() => _expression)).label("expression"),
                str(";").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> inherit => field ??=
            chain((Parser<object?>[])[
                str("inherit").Map(x => (object?)x),
                (lazyp(() => inherited_attrs)).label("attrs"),
                str(";").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> inherit_from => field ??=
            chain((Parser<object?>[])[
                str("inherit").Map(x => (object?)x),
                str("(").Map(x => (object?)x),
                (lazyp(() => _expression)).label("expression"),
                str(")").Map(x => (object?)x),
                (lazyp(() => inherited_attrs)).label("attrs"),
                str(";").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> attrpath => field ??=
            chain((Parser<object?>[])[
                (choice((Parser<object?>[])[
                    attempt(lazyp(() => identifier)),
                    attempt(lazyp(() => string_expression)),
                    attempt(lazyp(() => interpolation)),
                ])).label("attr"),
                many(LEXEME(chain((Parser<object?>[])[
                    str(".").Map(x => (object?)x),
                    (choice((Parser<object?>[])[
                        attempt(lazyp(() => identifier)),
                        attempt(lazyp(() => string_expression)),
                        attempt(lazyp(() => interpolation)),
                    ])).label("attr"),
                ]).Map(x => (object?)x))).Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> inherited_attrs => field ??=
            many1(LEXEME((choice((Parser<object?>[])[
                attempt(lazyp(() => identifier)),
                attempt(lazyp(() => string_expression)),
                attempt(lazyp(() => interpolation)),
            ])).label("attr"))).Map(x => (object?)x);
        
        public virtual Parser<object?> _immediate_interpolation => field ??=
            chain((Parser<object?>[])[
                str("${").Map(x => (object?)x),
                (lazyp(() => _expression)).label("expression"),
                str("}").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> interpolation => field ??=
            chain((Parser<object?>[])[
                str("${").Map(x => (object?)x),
                (lazyp(() => _expression)).label("expression"),
                str("}").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> list_expression => field ??=
            chain((Parser<object?>[])[
                str("[").Map(x => (object?)x),
                many(LEXEME((lazyp(() => _expr_select_expression)).label("element"))).Map(x => (object?)x),
                str("]").Map(x => (object?)x),
            ]).Map(x => (object?)x);
        
        public virtual Parser<object?> comment => field ??=
            choice((Parser<object?>[])[
                attempt(chain((Parser<object?>[])[
                    str("#").Map(x => (object?)x),
                    regex(".*").Map(x => (object?)x),
                ]).Map(x => (object?)x)),
                attempt(chain((Parser<object?>[])[
                    str("/*").Map(x => (object?)x),
                    regex("[^*]*\\*+([^/*][^*]*\\*+)*").Map(x => (object?)x),
                    str("/").Map(x => (object?)x),
                ]).Map(x => (object?)x)),
            ]);
        
        public abstract Parser<object?> string_fragment { get; }
        
        public abstract Parser<object?> _indented_string_fragment { get; }
        
        public abstract Parser<object?> _path_start { get; }
        
        public abstract Parser<object?> path_fragment { get; }
        
        public abstract Parser<object?> dollar_escape { get; }
        
        public abstract Parser<object?> _indented_dollar_escape { get; }
        
        public virtual Parser<object?> WHITESPACE => field ??=
            choice((Parser<object?>[])[
                attempt(regex("\\s").Map(x => (object?)x)),
                attempt(lazyp(() => comment)),
            ]);
        
        public virtual Parser<A> LEXEME<A>(Parser<A> p) => from _ in optional(WHITESPACE) from result in p select result;
    }
}
