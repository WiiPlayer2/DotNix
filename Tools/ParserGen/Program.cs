using System.CodeDom.Compiler;
using System.CommandLine;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using ParserGen;

var inputArgument = new Argument<FileInfo?>("input");
var outputArgument = new Argument<FileInfo?>("output");

var generateCommand = new Command("generate")
{
    inputArgument,
    outputArgument,
};
generateCommand.SetAction(Generate);

var rootCommand = new RootCommand()
{
    generateCommand,
};

var result = rootCommand.Parse(args);
return await result.InvokeAsync();

async Task<int> Generate(ParseResult parseResult, CancellationToken cancellationToken)
{
    var inputFile = parseResult.GetRequiredValue(inputArgument) ?? throw new InvalidOperationException();
    var outputFile = parseResult.GetRequiredValue(outputArgument) ?? throw new InvalidOperationException();

    var options = new JsonSerializerOptions(JsonSerializerDefaults.General)
    {
        Converters =
        {
            new JsonStringEnumConverter(),
            new LstConverterFactory(),
        },
    };
        
    Console.WriteLine("Loading grammar file...");
    await using var inputStream = inputFile.OpenRead();
    var grammarJson = await JsonSerializer.DeserializeAsync<GrammarDto>(inputStream, options, cancellationToken) ??
                      throw new InvalidOperationException();

    Console.WriteLine("Generating parser...");
    await using var outputWriter = new IndentedTextWriter(outputFile.CreateText(), "    ");
    var ruleWriter = new RuleWriter(outputWriter);
    
    await outputWriter.WriteLineAsync("""
                                      // <auto-generated />
                                      #nullable enable
                                      
                                      using System.Diagnostics.CodeAnalysis;
                                      using System.Text.RegularExpressions;
                                      
                                      namespace DotNix.Parsing;

                                      internal static partial class TreeSitter
                                      {
                                      """);
    using (outputWriter.WithIndent())
    {
        await outputWriter.WriteLineAsync("private static Parser<object?> TODO => throw new NotImplementedException();");
        await outputWriter.WriteLineAsync();

        await outputWriter.WriteLineAsync("""
                                          private static Parser<string> regex([StringSyntax("regex")] string pattern)
                                          {
                                              var regex_ = new Regex(pattern);
                                              return input =>
                                              {
                                                  var match = regex_.Match(input.Value, input.Index);
                                                  if (!match.Success || match.Index != input.Index)
                                                      return ParserResult.EmptyError<string>(ParserError.Message(input.Pos, $"Did not match pattern"));
                                          
                                                    return str(match.Value)(input);
                                              };
                                          }
                                          """);
        await outputWriter.WriteLineAsync();
        
        await outputWriter.WriteLineAsync("public abstract partial class Rules");
        await outputWriter.WriteLineAsync("{");
        using (outputWriter.WithIndent())
        {
            foreach (var rule in grammarJson.Rules)
            {
                await outputWriter.WriteLineAsync($"public virtual Parser<object?> {rule.Key} => field ??=");
                using (outputWriter.WithIndent())
                {
                    // await outputWriter.WriteAsync("attempt(");
                    await ruleWriter.WriteRule(rule.Value, true);
                    await outputWriter.WriteLineAsync(";");
                }

                await outputWriter.WriteLineAsync();
            }

            foreach (var externalRule in grammarJson.Externals)
            {
                if (externalRule is not RuleDto.Symbol_ symbolRule)
                    throw new InvalidOperationException();

                await outputWriter.WriteLineAsync($"public abstract Parser<object?> {symbolRule.Name} {{ get; }}");
                await outputWriter.WriteLineAsync();
            }
            
            await outputWriter.WriteLineAsync("public virtual Parser<object?> WHITESPACE => field ??=");
            using (outputWriter.WithIndent())
            {
                await ruleWriter.WriteRule(RuleDto.Choice(grammarJson.Extras), true);
                await outputWriter.WriteLineAsync(";");
            }
            await outputWriter.WriteLineAsync();

            await outputWriter.WriteLineAsync("public virtual Parser<A> LEXEME<A>(Parser<A> p) => from _ in optional(WHITESPACE) from result in p select result;");
        }
        await outputWriter.WriteLineAsync("}");
    }
    await outputWriter.WriteLineAsync("}");
    await outputWriter.FlushAsync();
    
    Console.WriteLine("Done.");
    return 0;
}